#!/usr/bin/env python
import rospy
import math
import numpy as np
import matplotlib.pyplot as plt
import csv
from sensor_msgs.msg import LaserScan # For subscribing Laser Scan
from sklearn.neighbors import NearestNeighbors # For ICP
from sensor_msgs.msg import JointState # For subscrbing JointState to compute odom
from scipy import sparse
from scipy.sparse.linalg import inv, spsolve
from geometry_msgs.msg import Point, Pose, Quaternion, Twist, Vector3
import tf
from nav_msgs.msg import Odometry
class ODOM():
    def __init__(self):
        '''
        To realize the drift effect, the odometry information has to be generated by ourself.
        Because the odom topic from gazebo is the "Ground Truth" data. Hence it is without any noise.
        '''
        # rospy.init_node('odometry_construction', anonymous=True)
        
        # Parameters of the hardware
        self.wheel_radius = 0.033
        self.wheel_dist = 0.2

        # Init encoder value
        self.enc_Left = 0
        self.enc_Right = 0

        # List
        self.omega_list_L = [0,0,0]
        self.omega_list_R = [0,0,0]

        # Pose
        self.x = 0
        self.y = 0
        self.yaw = -3.14

        # 
        self.x_list = []
        self.y_list = []

        # rospy
        self.r = rospy.Rate(10)
        self.odom_broadcaster = tf.TransformBroadcaster()
        rospy.Subscriber('/solamr_1/joint_states', JointState, self.get_encoder)
        # rospy.Subscriber('/solamr_1/imu', Imu, self.get_imu)
        # self.odom_pub = rospy.Publisher("/solamr_1/wheel_odom", Odometry, queue_size=50)

        # while not rospy.is_shutdown():
        #     pass
        #     self.r.sleep()

    def publish_odom(self, vx, wz):
        current_time = rospy.Time.now()
        odom = Odometry()
        odom.header.stamp = current_time
        odom.header.frame_id = "solamr_1/odom"
        odom.child_frame_id = "solamr_1/base_footprint"
        odom.twist.twist = Twist(Vector3(vx, 0, 0), Vector3(0, 0, wz))

        odom_quat = tf.transformations.quaternion_from_euler(0, 0, self.yaw)
        odom.pose.pose = Pose(Point(self.x, self.y, 0.), Quaternion(*odom_quat))

        # self.odom_pub.publish(odom)

    # def get_imu(self, msg):
    #     wz = msg.angular_velocity.z
    #     ax = msg.linear_acceleration.x

    def get_encoder(self, msg):
        dt = 1 / 30.0
        fs = 30.0

        enc_L = msg.position[1]
        enc_R = msg.position[0]

        omega_L = (enc_L - self.enc_Left)  *fs
        omega_R = (enc_R - self.enc_Right) *fs

        self.enc_Left = enc_L
        self.enc_Right = enc_R

        self.omega_list_L.append(omega_L)
        self.omega_list_R.append(omega_R)

        omega_L = self.lowpass_filter(self.omega_list_L)
        omega_R = self.lowpass_filter(self.omega_list_R)

        vx, wz = self.cal_twitst(omega_R, omega_L)

        # self.publish_odom(vx, wz)

        self.x += vx * math.cos(self.yaw) * dt
        self.y += vx * math.sin(self.yaw) * dt
        self.yaw += wz * dt

        self.x_list.append(self.x)
        self.y_list.append(self.y)

        # print("x:%f"%self.x)
        # print("y:%f"%self.y)

        
    def lowpass_filter(self, data_list):
        
        return ( data_list[-1] + 2 * data_list[-2] + data_list[-3] ) / 4

    def cal_twitst(self, wR, wL):

        vx = (wR + wL)/2 * self.wheel_radius
        wz = (wR - wL) * self.wheel_radius / self.wheel_dist
        
        return vx, wz

class Segment():
    def __init__(self, x, y):
        '''
        Parameters:
        d_thres : for segmentation of the consecutive data points.
        d_break_thres : for segmentation of the breakpoints. 
        
        '''
        self.d_thres = 5
        self.d_break_thres = 1
        self.shape_thres = 0.07
        self.R_thres = 1.5
        
        self.circle_thres = (math.pi/180)*60
        self.corner_thres = 0.7

        self.seg = []
        self.do_segment(x, y)
        self.seg = self.classify_segment_type(self.seg)
        self.seg = self.corner_merger_operation(self.seg)
        self.landmark = self.do_landmark(self.seg)


    def do_segment(self, x, y):
        '''
        Input:
        x: 1xn, ndarray
        y: 1xn, ndarray
        '''

        for i in range(len(x)):
            
            d_sum = 0
            for L in range(len(x) - 1):
                d       = cal_dist( x[0] , y[0] , x[L+1] , y[L+1] )
                d_conti = cal_dist( x[L] , y[L] , x[L+1] , y[L+1] )
                d_sum   = d_sum + d_conti
                
                if (d_sum - d) > self.d_thres or d_conti > self.d_break_thres:
                    
                    # If number of a seg is too less, then it won't form a seg.
                    # 因為相鄰太遠的點也會想要形成seg, 但很多情況下此seg僅有一個元素. 
                    if len(x[0:L+1]) < 5:
                        pass
                    else:
                        self.seg.append([
                            x[0:L+1],
                            y[0:L+1],
                            []
                        ])
                    x = x[L+1 : len(x)]
                    y = y[L+1 : len(y)]

                    break


            if len(x) <= 5:
                self.seg[-1][0] = np.hstack((self.seg[-1][0] , x)) 
                self.seg[-1][1] = np.hstack((self.seg[-1][1] , y))
                break
        
        # print("=== First segmentation done, result is : ===")
        # for i in range(len(self.seg)):
        #     print(len(self.seg[i][0]))
        

    def classify_segment_type(self, seg):
        
        # for loop : "number of row" times
        for i in range( len(seg) ):
            x = seg[i][0]
            y = seg[i][1]

            x0 = x[0]
            y0 = y[0]

            xn = x[-1]
            yn = y[-1]

            xm = np.mean(x)
            ym = np.mean(y)

            _, _, r = cal_circle([x0, xm, xn], [y0, ym, yn])
            
            if r > self.R_thres:
                seg[i][2] = "line"
                
            else:
                seg[i][2] = "circle"
        
        return seg
                
    def corner_merger_operation(self, seg):
        k = 0
        i = -1
        for j in range(len(seg) - 1):
            
            i = i + 1 + k
            k = 0

            if i+1 >= len(seg):
                break

            x1 = seg[i][0]
            y1 = seg[i][1]
            # x1m = np.mean(x1)
            # y1m = np.mean(y1)
            
            x2 = seg[i+1][0]
            y2 = seg[i+1][1]
            # x2m = np.mean(x2)
            # y2m = np.mean(y2)

            val = cal_acos([ x1[-1] - x1[0], y1[-1] - y1[0] ], [ x2[-1] - x2[0], y2[-1] - y2[0] ])

            if seg[i][2] == "circle":
            
                # circle , circle
                if seg[i][2] == seg[i+1][2]:
                    # 合併Operation
                    seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                    seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))
                    seg.pop(i+1)
                    k = -1

                # circle , line   
                else:                       
                    # 判斷轉角
                    if val > self.corner_thres:
                        k = 0
                        
                    # 合併circle (後者理當是Circle，但是誤判成Line的情況)
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))                
                        seg.pop(i+1)
                        k = -1
            # seg[i][2] == "line"    
            else:
                
                # line , line
                if seg[i][2] == seg[i+1][2]:  
                    
                    
                    # 判斷轉角
                    if val > self.corner_thres:  
                        pass
                        
                        
                    # 合併line
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))                    
                        seg.pop(i+1)
                        k = -1
                        
                    
                # line , circle
                else:                      
                    
                    
                    # 判斷轉角
                    if val > self.corner_thres:
                        pass
                        
                        
                    # 合併line (後者理當是Line，但是誤判成Circle的情況)
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))
                        seg.pop(i+1)
                        k = -1
        return seg

    def do_landmark(self, seg):
        circle_num = 0
        for i in range(len(seg)):
            if seg[i][2] == "circle":
                circle_num = circle_num + 1
            
        corner_num = 0
        for i in range( len(seg) - 1 ):
            
            x1 = seg[i][0][-1]
            y1 = seg[i][1][-1]
            x2 = seg[i+1][0][0]
            y2 = seg[i+1][1][0]

            d = cal_dist(x1,y1,x2,y2)
            if d < self.d_break_thres:
                corner_num = corner_num + 1
            


        landmark =  [   ["corner",  corner_num],
                        ["circle",  circle_num] ]
        return landmark

class LiDAR_Association():

    def __init__(self, topic_name='/solamr_1/scan_lidar'):
        self.landmark = None
        self.scan = None
        rospy.Subscriber(topic_name, LaserScan, self.get_lidar)
        
    def get_lidar(self, msg):
        
        point = []
        for ind, dist in enumerate(msg.ranges):
            if dist >= msg.range_min and dist <= msg.range_max:
                
                x = dist * math.cos(ind * math.pi / 725)
                y = dist * math.sin(ind * math.pi / 725)
                point.append([
                    x,
                    y
                ])
        # self.px = [i[0] for i in point]
        # self.py = [i[1] for i in point]
        self.scan = np.array(point)
        px = self.scan[:,0]
        py = self.scan[:,1]
        Seg = Segment(px, py)
        self.landmark = Seg.landmark

class ICP():
    def __init__(self):
        pass


    def best_fit_transform(self, A, B):
        '''
        Calculates the least-squares best-fit transform between corresponding 2D points A->B
        Input:
        A: Nx2 numpy array of corresponding 3D points
        B: Nx2 numpy array of corresponding 3D points
        Returns:
        T: 3x3 homogeneous transformation matrix
        R: 2x2 rotation matrix
        t: 2x1 column vector
        '''
        
        # If true, continue ; if false, break.
        assert len(A) == len(B)

        # translate points to their centroids
        centroid_A = np.mean(A, axis=0)
        centroid_B = np.mean(B, axis=0)
        AA = A - centroid_A
        BB = B - centroid_B

        # rotation matrix
        W = np.dot(BB.T, AA)
        U, s, VT = np.linalg.svd(W)
        R = np.dot(U, VT)

        # special reflection case
        if np.linalg.det(R) < 0:
            VT[-1, :] *= -1
            R = np.dot(U, VT)


        # translation
        t = centroid_B.T - np.dot(R, centroid_A.T)

        # homogeneous transformation
        T = np.identity(3)
        T[0:2, 0:2] = R
        T[0:2, 2] = t

        return T, R, t

    def nearest_neighbor(self, src, dst):
        '''
        Find the nearest (Euclidean) neighbor in dst for each point in src
        Input:
            src: Nx2 array of points
            dst: Nx2 array of points
        Output:
            distances: Euclidean distances (errors) of the nearest neighbor
            indecies: dst indecies of the nearest neighbor
        '''

        # indecies = np.zeros(src.shape[0], dtype=np.int)
        # distances = np.zeros(src.shape[0])
        
        # # i: index ; s: element in src
        # for i, s in enumerate(src):
        #     min_dist = np.inf

        #     # j: index ; d: element in dst
        #     for j, d in enumerate(dst):
        #         dist = np.linalg.norm(s-d)
        #         if dist < min_dist:
        #             min_dist = dist
        #             indecies[i] = j
        #             distances[i] = dist   
        
        neigh = NearestNeighbors(n_neighbors=1)
        neigh.fit(dst)
        distances, indices = neigh.kneighbors(src, return_distance=True)
        return distances.ravel(), indices.ravel()

        # return distances, indecies

    def icp(self, A, B, init_pose=None, max_iterations=100, tolerance=0.01, max_dist=0.5):
        '''
        The Iterative Closest Point method
        Input:
            A: Nx2 numpy array of source 3D points
            B: Nx2 numpy array of destination 3D point
            init_pose: 3x3 homogeneous transformation
            max_iterations: exit algorithm after max_iterations
            tolerance: convergence criteria
        Output:
            T: final homogeneous transformation
            distances: Euclidean distances (errors) of the nearest neighbor
        '''

        # Check the dimenstion is the same
        assert A.shape[1] == B.shape[1]  

        # get dimensions, m should be 2
        m = A.shape[1]
        


        # make points homogeneous, copy them so as to maintain the originals
        src = np.ones((m+1, A.shape[0]))
        dst = np.ones((m+1, B.shape[0]))
        src[0:m, :] = np.copy(A.T)
        dst[0:m, :] = np.copy(B.T)
        
        # apply the initial pose estimation
        if init_pose is not None:
            src = np.dot(init_pose, src)

        prev_error = 0

        for iteration in range(max_iterations):
            # find the nearest neighbours between the current source and destination points
            distances, indicies = self.nearest_neighbor(src[0:m, :].T, dst[0:m, :].T)


            # Remove Outliers
            j = 0
            src_good = []
            src_indicies_good = []
            dst_indicies_good = []
            for i, distance in enumerate(distances):
                if distance <= max_dist*2.0/(iteration + 1.0):
                # if distance <= max_dist:
                    src_good.append([
                        src[0, i],
                        src[1, i]
                    ])
                    dst_indicies_good.append(indicies[i])
                    src_indicies_good.append(i)
                    
                    j += 1

            src_good = np.array(src_good).T
            dst_good = dst[0:m, dst_indicies_good] 
            
            # compute the transformation between the current source and nearest destination points
            # T,_,_ = self.best_fit_transform(src[0:m, :].T, dst[0:m ,indicies].T)
            T,_,_ = self.best_fit_transform(src_good.T, dst_good.T)

            # update the current source, current source will converge to destination.
            src = np.dot(T, src)

            # check error
            mean_error = np.sum(distances) / distances.size
            if abs(prev_error-mean_error) < tolerance:
                break
            prev_error = mean_error

        # calculcate final tranformation
        T,_,_ = self.best_fit_transform(A, src[0:m, :].T)

        return T, distances
        


# Function Area
# -------------------
def cal_acos(v1, v2):
    '''
    Input:
    v1 : Input vector.
    v2 : Input vector.
    
    Output:
    value : Angle between these two vectors. (unit: rad)
    '''
    d1 = (v1[0]**2 + v1[1]**2)**(0.5)
    d2 = (v2[0]**2 + v2[1]**2)**(0.5)
    # print("d1:%f"%d1)
    # print("d2:%f"%d2)

    value = math.acos( (v1[0]*v2[0]+v1[1]*v2[1])/(d1*d2) )
    return value

def cal_circle(x, y):
    '''
    Input:
    x : List or array which stores 3 data respectively.
    y : List or array which stores 3 data respectively.
    
    Output:
    xc : X coordinate of the center.
    yc : X coordinate of the center.
    R  : Radius of the center.
    '''

    A = np.array([
        [ 2*x[0], 2*y[0], 1 ],
        [ 2*x[1], 2*y[1], 1 ],
        [ 2*x[2], 2*y[2], 1 ]
    ])
    B = np.array([
        [ x[0]**2 + y[0]**2 ],
        [ x[1]**2 + y[1]**2 ],
        [ x[2]**2 + y[2]**2 ]
    ])

    if abs(np.linalg.det(A)) < 0.0001:
        xc = None
        yc = None
        R = 100000
         
    
    else:
        X = np.linalg.solve(A, B)
        xc = X[0]
        yc = X[1]
        R  = ( X[2] + xc**2 + yc**2 )**(0.5)

    return xc, yc, R

def cal_dist(xi, yi, xf, yf):
    
    dx = xi - xf
    dy = yi - yf
    
    return (dx**2 + dy**2)**(0.5)

def read_csv(csv_file_scan='case1.csv'):
    
    '''
    Read the scan data set from the csv file.
    '''
    with open(csv_file_scan) as scan:
        scan_csv = csv.reader(scan)
        scan_list = []
        # Data from csv file are "string", 
        # so they need to be change to float type by "list(map(float, row))" operation.
        for row in scan_csv:
            x = list(map(float, row))
            scan_list.append(x)
        scan_set = np.array(scan_list)
    
    return scan_set

def t2v(T):
    '''(Done)
    homogeneous transformation to vector
    '''
    v = np.zeros((3,1))
    v[0:2, 0] = T[0:2, 2]
    v[2, 0] = math.atan2(T[0,1], T[0,0])
    return v

def v2t(vector):
    '''(Done)
    vector to homogeneous transformation
    From local to global
    [              |
            Rotaion  | Translation
        _____________|____________
            0   |   0 |      1
    ]
    '''
    c = math.cos(vector[2])
    s = math.sin(vector[2])
    x = float(vector[0])
    y = float(vector[1])
    T = np.array([
        [c,  -s,  x],
        [s,   c,  y],
        [0,   0,  1]
    ])
    return T

# Graph Optimization
class PoseGraph():

    def __init__(self):
        
        '''(Done)
        To impelement this graph slam optimizer, please follow the steps below:
        1. Use the "create_zero_constructor" function with input: 
            - node_data_set : 5xn array
            - edge_data_set : 4xn array

        2. Use the "optimize" function with input:
            - num_iteration : Max iteration times, default = 10

        3. After the iteration, the result is recorded in "self.node".
        -----------------------------------------------------------------------
        Parameter:
            * node : Pose nodes in graph
            * edge : Edge in graph
            * H    : Information matrix
            * b    : Information vector
        '''
        
        # self.fig, self.ax = plt.subplots()
        plt.ion()
        # plt.show()

        return
        

    def create_zero_constructor(self, node_set, edge_set):

        '''(Done)
        Create zeros constructor of node and edge.
        ------------------------------------------
        
        (5xn array)
        self.node = [
             id |     |  id >> index                        : int
              x |     |   x >> pose of x                    : float
              y | ... |   y >> pose of y                    : float
            yaw |     | yaw >> pose of yaw                  : float
             rt |     |  rt >> transformation  : 3x3 array  : float
        ]

        (4xn array)
        self.edge = [
            id_from |     | >> index                               : int
              id_to | ... | >> index                               : int
               mean |     | >> relative transformation : 3x1 array : float
               infm |     | >> covariance information  : 3x3 array : float
        ]
        '''

        self.length_node = len(node_set)
        self.length_edge = len(edge_set)
        
        self.node = []
        self.edge = []
        # self.node = np.zeros(np.shape(node_set))
        # self.edge = np.zeros(np.shape(edge_set))

        self.read_data(node_set, edge_set)
        return

    def read_data(self, node_set, edge_set):

        '''(Done)
        Read the node and edge data from the files.
        -------------------------------------------
        node_set: array of node data :4xN
              [0]:  id (list)
              [1]:   x (list)
              [2]:   y (list)
              [3]: yaw (list)

        edge_set: array of edge data :11xN
              [0]: id_from (list)
              [1]:   id_to (list)
            [2~4]:    mean (list)
           [5~10]:    infm (list)
        '''
        # put in node data.
        # node -> list[list1, list2, list3, ..., listN]
        for i_node in range(len(node_set)):
            
            self.node.append([
                int(node_set[i_node][0]),
                float(node_set[i_node][1]),
                float(node_set[i_node][2]),
                float(node_set[i_node][3])
            ])

        
        # -- The element of node[4,:] seems not being used.
        # for i in range(np.size(node_set,1)):
        #     self.node[4,i] = np.array([
        #         [cos(node_set[3,i]), -sin(node_set[3,i]), node_set[1,i]],
        #         [sin(node_set[3,i]),  cos(node_set[3,i]), node_set[2,i]],
        #         [                    0,                      0,             1]
        #     ]) 

        # put in edge data
        # edge -> list[list1, list2, list3, ..., listN]
        for i_edge in range(len(edge_set)):
            self.edge.append([
                int(edge_set[i_edge][0]),
                int(edge_set[i_edge][1]),
                edge_set[i_edge][2],
                edge_set[i_edge][3]
            ])

        return

    def optimize(self, num_iteration=5):

        '''(Done)
        Implement optimization to find a best solution for the graph.
        Optimization will stop when maximal iteration is reached.
        '''
        if num_iteration > 0:
            for i in range(num_iteration):
                print("No. %d iteration of optimization ..." %(i+1))
                self.iterate_graph_slam()
                print("No. %d iteration of optimization finished" %(i+1))
                print("=========================================")

                # plt plot
                x = [i[1] for i in self.node]
                y = [i[2] for i in self.node]
                # plt.figure()
                plt.cla()  
                plt.xlim((-5, 5))
                plt.ylim((-5, 5))
                plt.scatter(x, y, s=2)
                plt.plot(x, y)
                plt.pause(0.1)
            plt.ioff()
            plt.show()
            print("Done Graph Optimization !!")
            return  

        elif num_iteration < 0:
            print("Iteration Setting Error.")
            return
        else:
            print("No Iteration Process.")
            return

    def iterate_graph_slam(self):
        
        '''(Done)
        Iteration of pose graph optimization
        Details of the matrice below refer to paper "A Tutorial on Graph-Based SLAM."
        H : 3n x 3n matrix
        b : 3n x 1  matrix
        '''

        print("Iteration ...")

        print("Linearization ...")
        self.linearize_err_fcn()

        print("Solve the linear system ...")
        self.solve_lin_sys()
            
        return
        
    def linearize_err_fcn(self):
        
        '''(Done)
        Linearize error functions and formulate a linear system
        '''

        # Create zero constructors of H and b 
        self.H = np.zeros( (3*self.length_node  , 3*self.length_node) )
        self.b = np.zeros( (3*self.length_node  , 1) )


        for i_edge in range( self.length_edge ):
            # No. i constraint
            ei = self.edge[i_edge]

            # i_node: id_from
            # j_node: id_to
            i_node  = ei[0]
            j_node  = ei[1]
            
            # T_z: Transformation Matrix
            T_z = self.v2t(ei[2])

            # omega: Convariance
            omega = ei[3]

            # v_i: pose of node i : x, y, yaw
            # v_j: pose of node j : x, y, yaw
            v_i = np.array([
                [ self.node[i_node][1] ],
                [ self.node[i_node][2] ],
                [ self.node[i_node][3] ] 
            ])
            v_j = np.array([
                [ self.node[j_node][1] ],
                [ self.node[j_node][2] ],
                [ self.node[j_node][3] ]
            ])
            

            # Construct transformation from node to global frame
            T_i = self.v2t(v_i)
            T_j = self.v2t(v_j)

            R_i = T_i[0:2, 0:2]
            R_z = T_z[0:2, 0:2]

            # 1st order Derivative 
            si = math.sin(v_i[2])
            ci = math.cos(v_i[2])
            dR_i = np.array([
                [-si,  ci],
                [-ci, -si]
                            ]).transpose()
            
            dt_ij = v_j[0:2] - v_i[0:2]

            # Calculation of Jacobians
            # A: 3x3
            # B: 3x3

            A = np.hstack([ np.dot( -R_z.transpose(), R_i.transpose() ) , np.dot( np.dot( R_z.transpose(), dR_i.transpose() ), dt_ij ) ])
            A = np.vstack([ A, np.array([0,0,-1]) ])

            B = np.hstack([ np.dot( R_z.transpose(), R_i.transpose() ), np.array([[0],[0]]) ])
            B = np.vstack([ B, np.array([0,0,1]) ])

            # Calculation of error vector
            e = self.t2v( np.linalg.inv(T_z).dot( np.linalg.inv(T_i) ).dot(T_j) )
            
            # Formulation of updated data of H & b
            # H_ii: 3x3  | H_ij: 3x3
            # -----------|------------
            # H_ji: 3x3  | H_jj: 3x3
            # b_i:  3x1
            # b_j:  3x1
            H_ii =  A.transpose().dot(omega).dot(A)
            H_ij =  A.transpose().dot(omega).dot(B)
            H_jj =  B.transpose().dot(omega).dot(B)
            b_i  =  -A.transpose().dot(omega).dot(e)
            b_j  =  -B.transpose().dot(omega).dot(e)

            # Index of updated data 
            i_ind_start, i_ind_end = self.id2ind(i_node)
            j_ind_start, j_ind_end = self.id2ind(j_node)
            
            # Update H and b matrix
            self.H[i_ind_start : i_ind_end , i_ind_start : i_ind_end] = self.H[i_ind_start : i_ind_end , i_ind_start : i_ind_end] + H_ii
            self.H[i_ind_start : i_ind_end , j_ind_start : j_ind_end] = self.H[i_ind_start : i_ind_end , j_ind_start : j_ind_end] + H_ij
            self.H[j_ind_start : j_ind_end , i_ind_start : i_ind_end] = self.H[j_ind_start : j_ind_end , i_ind_start : i_ind_end] + H_ij.transpose()
            self.H[j_ind_start : j_ind_end , j_ind_start : j_ind_end] = self.H[j_ind_start : j_ind_end , j_ind_start : j_ind_end] + H_jj
            
            self.b[i_ind_start : i_ind_end] = self.b[i_ind_start : i_ind_end] + b_i
            self.b[j_ind_start : j_ind_end] = self.b[j_ind_start : j_ind_end] + b_j
          
        return

    def solve_lin_sys(self):
        
        '''(Done)
        Solves the linear system and update all pose nodes.
        The system Hx = b is obtained only from relative constraints.
        H is not full rank.
        We solve this by anchoring the position of the 1st vertex
        This can be expressed by adding the equation
        dx(1:3,1) = 0
        which is equivalent to the following
        '''
        
        self.H[0:3, 0:3] = self.H[0:3, 0:3] + np.eye(3)
        H_sparse = sparse.csc_matrix(self.H)
        dx = spsolve(H_sparse, self.b)
        dpose = np.reshape(dx, (3, self.length_node), order='F')
        

        for i_node in range(self.length_node):
            for n in range(len(dpose)):
                self.node[i_node][n+1] = self.node[i_node][n+1] + dpose[n, i_node]

        return

    def v2t(self, vector):
        
        '''(Done)
        vector to homogeneous transformation
        From local to global
        [              |
              Rotaion  | Translation
          _____________|____________
             0   |   0 |      1
        ]
        '''
        c = math.cos(vector[2])
        s = math.sin(vector[2])
        x = float(vector[0])
        y = float(vector[1])
        T = np.array([
            [c,  -s,  x],
            [s,   c,  y],
            [0,   0,  1]
        ])
        return T

    def id2ind(self, id):
        
        '''(Done)
        Converts id to indices in H and b
        '''
        ind_start = 3*id
        ind_end   = 3*id + 3
        return ind_start, ind_end

    def t2v(self, T):
        
        '''(Done)
        homogeneous transformation to vector
        '''
        v = np.zeros((3,1))
        v[0:2, 0] = T[0:2, 2]
        v[2, 0] = math.atan2(T[1,0], T[0,0])
        return v




# Main Class
class CAR():
    def __init__(self, topic='/solamr_1/scan_lidar'):
        self.lidar = LiDAR_Association(topic)
        self.odom = ODOM()
        # self.scan_icp = ICP()

if __name__ == "__main__":
    rospy.init_node('SLAM_Infomation_Construction', anonymous=True)
    rate = rospy.Rate(0.5)

    try:
        # List Set
        '''
        Node Set
        [0]: ID now
        [1]: Node_Pose (global)
        [2]: Landmark
        [3]: Scan
        -------------------------
        Edge Set
        [0]: ID from
        [1]: ID to
        [2]: Edge Pose (relative)
        [3]: Covariance 
        '''
        Node_set = []
        Edge_set = []
        
        node_id = 0
        
        car = CAR('/solamr_1/scan_lidar')
        
        scan_list = []
        Edge = []

        x = [0]
        y = [0]

        while not rospy.is_shutdown():
        
            if car.lidar.landmark is not None: 
                print("while loop is running now !!")

                # Store Node data
                Node_set.append([
                    node_id,
                    car.odom.x,
                    car.odom.y, 
                    car.odom.yaw,
                    car.lidar.landmark,
                    car.lidar.scan
                ])
                print(Node_set[-1][4])
                # print("===================")
                
                # Store Edge data with t = k & t = k - 1
                if len(Node_set) >= 2:
                    # which should be first? Need check
                    A = Node_set[-2][5]
                    B = Node_set[-1][5]
                    
                    T,_ = ICP().icp(A,B)
                    pose = t2v(T)
                    Cov = np.array([
                        [20,  0,     0],
                        [ 0, 20,     0],
                        [ 0,  0, 10000]
                    ])
                    Edge_set.append([
                        Node_set[-2][0],
                        Node_set[-1][0],
                        pose,
                        Cov
                    ])
                    x.append(x[-1] + Edge_set[-1][2][0])
                    y.append(y[-1] + Edge_set[-1][2][1])
                    print(Edge_set[-1][2])
                    print("===================")

                
                '''
                    # Loop Closure
                    # candidate = []
                    for ind ,node in enumerate(Node_set):
                        # Same Landmark & Node Interval > 10
                        if (node[4] == Node_set[-1][4]) and (Node_set[-1][0] - node[0] > 10):
                            # candidate.append(Node_set[ind])
                            A = node[5]
                            B = Node_set[-1][5]
                            T,_ = ICP().icp(A,B)
                            pose = t2v(T)
                            # Define the node from & node to
                            start_node = node[0]
                            end_node = Node_set[-1][0]
                            edge_cond_list = []


                            while not start_node == end_node:
                                # Define a tmp list to store the info with 1st element being start_node, node from.
                                edge_tmp = []
                                for ind ,e in enumerate(Edge_set):
                                    if e[0] == start_node:
                                        edge_tmp.append(Edge_set[ind])

                                # Define a list b to store 2nd element (node_to) in edge_tmp.
                                # This is used for finding the index of maximal node_to (M) in edge_tmp.
                                b = [i[1] for i in edge_tmp]
                                M = b.index(max(b))

                                # Update start_node
                                start_node = edge_tmp[M][1]

                                # Store relative pose in edge_cond_list for later checking the T and T_new
                                edge_cond_list.append(edge_tmp[M])

                            pose_cond = [i[2] for i in edge_cond_list]
                            pose_new = np.sum(pose_cond, axis=0)
                            T_new = v2t(pose_new)
                            
                            # Check T & T_new
                            unit_vector = np.array([
                                [1],
                                [1],
                                [1]
                            ])
                            
                            del_vector = (T - T_new).dot(unit_vector)
            
                            if (del_vector[0]**2 + del_vector[1]**2 + del_vector[2]**2)**0.5 < 0.3:
                                
                                Edge_set.append([
                                    node[0],
                                    Node_set[-1][0],
                                    pose,
                                    Cov
                                ])
                                print("Loop Closure Success !!")
                                # print(Edge_set[-1][0], Edge_set[-1][1])
                                break
                            else:
                                print("Loop Closure Failed !!")
                                pass
                '''


                if node_id > 160:
                    break
                
                node_id += 1
                rate.sleep()
            
        # rospy.spin()

    except KeyboardInterrupt:
        pass

    finally:
        pass
        print("Done Collecting Data.")
        # a = PoseGraph()
        # a.create_zero_constructor(Node_set, Edge_set)
        # a.optimize(20)

        # By wheel odom
        # x = [i[1] for i in Node_set]
        # y = [i[2] for i in Node_set]
        plt.figure()
        plt.xlim((-7, 7))
        plt.ylim((-7, 7))
        plt.plot(x, y)
        # plt.scatter(a.x_list, a.y_list, s=2)
        plt.show()