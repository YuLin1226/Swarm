#!/usr/bin/env python

import rospy
import math
import numpy as np
# from std_msgs.msg import Float64
# from nav_msgs.msg import Odometry
from sensor_msgs.msg import JointState
from sensor_msgs import Imu
import matplotlib.pyplot as plt
# import geometry_msgs.msg

class ODOM():
    def __init__(self):
        '''
        To realize the drift effect, the odometry information has to be generated by ourself.
        Because the odom topic from gazebo is the "Ground Truth" data. Hence it is without any noise.
        '''
        rospy.init_node('odometry_construction', anonymous=True)
        
        # Parameters of the hardware
        self.wheel_radius = 0.033
        self.car_width = 0.3

        # Init encoder value
        self.enc_Left = 0
        self.enc_Right = 0

        # List
        self.omega_list_L = [0,0,0]
        self.omega_list_R = [0,0,0]

        # Pose
        self.x = 0
        self.y = 0
        self.yaw = 0

        # 
        self.x_list = []
        self.y_list = []

        # rospy
        self.r = rospy.Rate(10)
        rospy.Subscriber('/solamr_1/joint_states', JointState, self.get_encoder)
        # rospy.Subscriber('/solamr_1/imu', Imu, self.get_imu)

        # while not rospy.is_shutdown():
        #     pass
        #     self.r.sleep()


    def get_imu(self, msg):
        wz = msg.angular_velocity.z
        ax = msg.linear_acceleration.x

    def get_encoder(self, msg):
        dt = 1 / 30.0
        fs = 30.0

        enc_L = msg.position[0]
        enc_R = msg.position[1]

        omega_L = (enc_L - self.enc_Left)  *fs
        omega_R = (enc_R - self.enc_Right) *fs

        self.enc_Left = enc_L
        self.enc_Right = enc_R

        self.omega_list_L.append(omega_L)
        self.omega_list_R.append(omega_R)

        omega_L = self.lowpass_filter(self.omega_list_L)
        omega_R = self.lowpass_filter(self.omega_list_R)

        vx, wz = self.cal_twitst(omega_R, omega_L)

        self.x += vx * math.cos(self.yaw) * dt
        self.y += vx * math.sin(self.yaw) * dt
        self.yaw += wz * dt

        self.x_list.append(self.x)
        self.y_list.append(self.y)

        print("x:%f"%self.x)
        print("y:%f"%self.y)

        
    def lowpass_filter(self, data_list):
        
        return ( data_list[-1] + 2 * data_list[-2] + data_list[-3] ) / 4

    def cal_twitst(self, wR, wL):

        vx = (wR + wL)/2 * self.wheel_radius
        wz = (wR - wL)/2 * self.wheel_radius / self.car_width

        return vx, wz
        


if __name__ == '__main__':

    # x = []
    # y = []
    a = ODOM()
    try:
        
        # while not rospy.is_shutdown():
        #     x.append(a.x)
        #     y.append(a.y)
        rospy.spin()

    except KeyboardInterrupt:
        pass

    finally:
        pass
        plt.figure()
        plt.xlim((-10, 30))
        plt.ylim((-10, 30))
        plt.plot(a.x_list, a.y_list)
        # plt.scatter(a.x_list, a.y_list, s=2)
        plt.show()