#!/usr/bin/env python

import rospy
import math
import numpy as np
# from std_msgs.msg import Float64
from nav_msgs.msg import Odometry
from sensor_msgs.msg import JointState
# from sensor_msgs import Imu
import matplotlib.pyplot as plt
from geometry_msgs.msg import Point, Pose, Quaternion, Twist, Vector3
import tf

class ODOM():
    def __init__(self):
        '''
        To realize the drift effect, the odometry information has to be generated by ourself.
        Because the odom topic from gazebo is the "Ground Truth" data. Hence it is without any noise.
        '''
        rospy.init_node('odometry_construction', anonymous=True)
        
        # Parameters of the hardware
        self.wheel_radius = 0.033
        self.wheel_dist = 0.2

        # Init encoder value
        self.enc_Left = 0
        self.enc_Right = 0

        # List
        self.omega_list_L = [0,0,0]
        self.omega_list_R = [0,0,0]

        # Pose
        self.x = 0
        self.y = 0
        self.yaw = -3.14

        # 
        self.x_list = []
        self.y_list = []

        # rospy
        self.r = rospy.Rate(10)
        self.odom_broadcaster = tf.TransformBroadcaster()
        rospy.Subscriber('/solamr_1/joint_states', JointState, self.get_encoder)
        # rospy.Subscriber('/solamr_1/imu', Imu, self.get_imu)
        self.odom_pub = rospy.Publisher("/solamr_1/wheel_odom", Odometry, queue_size=50)

        # while not rospy.is_shutdown():
        #     pass
        #     self.r.sleep()

    def publish_odom(self, vx, wz):
        current_time = rospy.Time.now()
        odom = Odometry()
        odom.header.stamp = current_time
        odom.header.frame_id = "solamr_1/odom"
        odom.child_frame_id = "solamr_1/base_footprint"
        odom.twist.twist = Twist(Vector3(vx, 0, 0), Vector3(0, 0, wz))

        odom_quat = tf.transformations.quaternion_from_euler(0, 0, self.yaw)
        odom.pose.pose = Pose(Point(self.x, self.y, 0.), Quaternion(*odom_quat))

        self.odom_pub.publish(odom)

    def get_imu(self, msg):
        wz = msg.angular_velocity.z
        ax = msg.linear_acceleration.x

    def get_encoder(self, msg):
        dt = 1 / 30.0
        fs = 30.0

        enc_L = msg.position[1]
        enc_R = msg.position[0]

        omega_L = (enc_L - self.enc_Left)  *fs
        omega_R = (enc_R - self.enc_Right) *fs

        self.enc_Left = enc_L
        self.enc_Right = enc_R

        self.omega_list_L.append(omega_L)
        self.omega_list_R.append(omega_R)

        omega_L = self.lowpass_filter(self.omega_list_L)
        omega_R = self.lowpass_filter(self.omega_list_R)

        vx, wz = self.cal_twitst(omega_R, omega_L)

        self.publish_odom(vx, wz)

        self.x += vx * math.cos(self.yaw) * dt
        self.y += vx * math.sin(self.yaw) * dt
        self.yaw += wz * dt

        self.x_list.append(self.x)
        self.y_list.append(self.y)

        # print("x:%f"%self.x)
        # print("y:%f"%self.y)

        
    def lowpass_filter(self, data_list):
        
        return ( data_list[-1] + 2 * data_list[-2] + data_list[-3] ) / 4

    def cal_twitst(self, wR, wL):

        vx = (wR + wL)/2 * self.wheel_radius
        wz = (wR - wL) * self.wheel_radius / self.wheel_dist
        
        return vx, wz
        
    
            

if __name__ == '__main__':

    # x = []
    # y = []
    a = ODOM()
    try:
        
        # while not rospy.is_shutdown():
        #     x.append(a.x)
        #     y.append(a.y)
        rospy.spin()

    except KeyboardInterrupt:
        pass

    finally:
        pass
        plt.figure()
        plt.xlim((-7, 7))
        plt.ylim((-7, 7))
        plt.plot(a.x_list, a.y_list)
        # plt.scatter(a.x_list, a.y_list, s=2)
        plt.show()