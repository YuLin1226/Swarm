#!/usr/bin/env python
#-*- coding: utf-8 -*-
import rospy
import math
import numpy as np
import matplotlib.pyplot as plt
from sensor_msgs.msg import LaserScan # For subscribing Laser Scan
from sensor_msgs.msg import JointState # For subscrbing JointState to compute odom
from geometry_msgs.msg import Point, Pose, Quaternion, Twist, Vector3
from nav_msgs.msg import Odometry
from car_msg.msg import Node, Edge, Optimized_Node
import tf

class ODOM():
    def __init__(self):
        '''
        To realize the drift effect, the odometry information has to be generated by ourself.
        Because the odom topic from gazebo is the "Ground Truth" data. Hence it is without any noise.
        '''
        # rospy.init_node('odometry_construction', anonymous=True)
        
        # Parameters of the hardware
        self.wheel_radius = 0.033
        self.wheel_dist = 0.2

        # Init encoder value
        self.enc_Left = 0
        self.enc_Right = 0

        # List
        self.omega_list_L = [0,0,0]
        self.omega_list_R = [0,0,0]

        # Pose
        self.x = 0
        self.y = 0
        self.yaw = -3.14

        # rospy
        self.odom_pub = rospy.Publisher("/solamr_1/wheel_odom", Odometry, queue_size=50)
        rospy.Subscriber('/solamr_1/joint_states', JointState, self.get_encoder)
        # rospy.Subscriber('/solamr_1/imu', Imu, self.get_imu)

    # def get_imu(self, msg):
    #     wz = msg.angular_velocity.z
    #     ax = msg.linear_acceleration.x

    def get_encoder(self, msg):
        dt = 1 / 30.0
        fs = 30.0

        enc_L = msg.position[1]
        enc_R = msg.position[0]

        omega_L = (enc_L - self.enc_Left)  *fs
        omega_R = (enc_R - self.enc_Right) *fs

        self.enc_Left = enc_L
        self.enc_Right = enc_R

        self.omega_list_L.append(omega_L)
        self.omega_list_R.append(omega_R)

        omega_L = self.lowpass_filter(self.omega_list_L)
        omega_R = self.lowpass_filter(self.omega_list_R)

        vx, wz = self.cal_twitst(omega_R, omega_L)

        self.x += vx * math.cos(self.yaw) * dt
        self.y += vx * math.sin(self.yaw) * dt
        self.yaw += wz * dt

        if self.yaw <= 0 or self.yaw >= 2*math.pi:
            self.yaw = self.yaw%(2*math.pi)

        self.publish_odom(vx, wz)

   
    def lowpass_filter(self, data_list):
        
        return ( data_list[-1] + 2 * data_list[-2] + data_list[-3] ) / 4

    def cal_twitst(self, wR, wL):

        vx = (wR + wL)/2 * self.wheel_radius
        wz = (wR - wL) * self.wheel_radius / self.wheel_dist
        
        return vx, wz

    def publish_odom(self, vx, wz):
        current_time = rospy.Time.now()
        odom = Odometry()
        odom.header.stamp = current_time
        odom.header.frame_id = "solamr_1/odom"
        odom.child_frame_id = "solamr_1/base_footprint"
        odom.twist.twist = Twist(Vector3(vx, 0, 0), Vector3(0, 0, wz))

        odom_quat = tf.transformations.quaternion_from_euler(0, 0, self.yaw)
        odom.pose.pose = Pose(Point(self.x, self.y, 0.), Quaternion(*odom_quat))

        self.odom_pub.publish(odom)

class Segment():
    def __init__(self, x, y):
        '''
        Parameters:
        d_thres : for segmentation of the consecutive data points.
        d_break_thres : for segmentation of the breakpoints. 
        
        '''
        self.d_thres = 5
        self.d_break_thres = 1
        self.shape_thres = 0.07
        self.R_thres = 1.5
        
        self.circle_thres = (math.pi/180)*60
        self.corner_thres = 0.7

        self.seg = []
        self.do_segment(x, y)
        self.seg = self.classify_segment_type(self.seg)
        self.seg = self.corner_merger_operation(self.seg)
        self.landmark = self.do_landmark(self.seg)


    def do_segment(self, x, y):
        '''
        Input:
        x: 1xn, ndarray
        y: 1xn, ndarray
        '''

        for i in range(len(x)):
            
            d_sum = 0
            for L in range(len(x) - 1):
                d       = cal_dist( x[0] , y[0] , x[L+1] , y[L+1] )
                d_conti = cal_dist( x[L] , y[L] , x[L+1] , y[L+1] )
                d_sum   = d_sum + d_conti
                
                if (d_sum - d) > self.d_thres or d_conti > self.d_break_thres:
                    
                    # If number of a seg is too less, then it won't form a seg.
                    # 因為相鄰太遠的點也會想要形成seg, 但很多情況下此seg僅有一個元素. 
                    if len(x[0:L+1]) < 5:
                        pass
                    else:
                        self.seg.append([
                            x[0:L+1],
                            y[0:L+1],
                            []
                        ])
                    x = x[L+1 : len(x)]
                    y = y[L+1 : len(y)]

                    break


            if len(x) <= 5:
                self.seg[-1][0] = np.hstack((self.seg[-1][0] , x)) 
                self.seg[-1][1] = np.hstack((self.seg[-1][1] , y))
                break
        
        # print("=== First segmentation done, result is : ===")
        # for i in range(len(self.seg)):
        #     print(len(self.seg[i][0]))
        

    def classify_segment_type(self, seg):
        
        # for loop : "number of row" times
        for i in range( len(seg) ):
            x = seg[i][0]
            y = seg[i][1]

            x0 = x[0]
            y0 = y[0]

            xn = x[-1]
            yn = y[-1]

            xm = np.mean(x)
            ym = np.mean(y)

            _, _, r = cal_circle([x0, xm, xn], [y0, ym, yn])
            
            if r > self.R_thres:
                seg[i][2] = "line"
                
            else:
                seg[i][2] = "circle"
        
        return seg
                
    def corner_merger_operation(self, seg):
        k = 0
        i = -1
        for j in range(len(seg) - 1):
            
            i = i + 1 + k
            k = 0

            if i+1 >= len(seg):
                break

            x1 = seg[i][0]
            y1 = seg[i][1]
            # x1m = np.mean(x1)
            # y1m = np.mean(y1)
            
            x2 = seg[i+1][0]
            y2 = seg[i+1][1]
            # x2m = np.mean(x2)
            # y2m = np.mean(y2)

            val = cal_acos([ x1[-1] - x1[0], y1[-1] - y1[0] ], [ x2[-1] - x2[0], y2[-1] - y2[0] ])

            if seg[i][2] == "circle":
            
                # circle , circle
                if seg[i][2] == seg[i+1][2]:
                    # 合併Operation
                    seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                    seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))
                    seg.pop(i+1)
                    k = -1

                # circle , line   
                else:                       
                    # 判斷轉角
                    if val > self.corner_thres:
                        k = 0
                        
                    # 合併circle (後者理當是Circle，但是誤判成Line的情況)
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))                
                        seg.pop(i+1)
                        k = -1
            # seg[i][2] == "line"    
            else:
                
                # line , line
                if seg[i][2] == seg[i+1][2]:  
                    
                    
                    # 判斷轉角
                    if val > self.corner_thres:  
                        pass
                        
                        
                    # 合併line
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))                    
                        seg.pop(i+1)
                        k = -1
                        
                    
                # line , circle
                else:                      
                    
                    
                    # 判斷轉角
                    if val > self.corner_thres:
                        pass
                        
                        
                    # 合併line (後者理當是Line，但是誤判成Circle的情況)
                    else:
                        
                        # 合併Operation
                        seg[i][0] = np.hstack(( seg[i][0] , seg[i+1][0] ))
                        seg[i][1] = np.hstack(( seg[i][1] , seg[i+1][1] ))
                        seg.pop(i+1)
                        k = -1
        return seg

    def do_landmark(self, seg):
        circle_num = 0
        for i in range(len(seg)):
            if seg[i][2] == "circle":
                circle_num = circle_num + 1
            
        corner_num = 0
        for i in range( len(seg) - 1 ):
            
            x1 = seg[i][0][-1]
            y1 = seg[i][1][-1]
            x2 = seg[i+1][0][0]
            y2 = seg[i+1][1][0]

            d = cal_dist(x1,y1,x2,y2)
            if d < self.d_break_thres:
                corner_num = corner_num + 1
            


        landmark =  [   ["corner",  corner_num],
                        ["circle",  circle_num] ]
        return landmark

class LiDAR_Association():

    def __init__(self, topic_name='/solamr_1/scan_lidar'):
        self.landmark = None
        self.scan = None
        rospy.Subscriber(topic_name, LaserScan, self.get_lidar)
        
    def get_lidar(self, msg):
        
        point = []
        for ind, dist in enumerate(msg.ranges):
            if dist >= msg.range_min and dist <= msg.range_max:
                
                x = dist * math.cos(ind * math.pi / 725)
                y = dist * math.sin(ind * math.pi / 725)
                point.append([
                    x,
                    y
                ])
        self.scan = np.array(point)
        px = self.scan[:,0]
        py = self.scan[:,1]
        Seg = Segment(px, py)
        self.landmark = Seg.landmark


# Function Area
# -------------------
def cal_acos(v1, v2):
    '''
    Input:
    v1 : Input vector.
    v2 : Input vector.
    
    Output:
    value : Angle between these two vectors. (unit: rad)
    '''
    d1 = (v1[0]**2 + v1[1]**2)**(0.5)
    d2 = (v2[0]**2 + v2[1]**2)**(0.5)
    # print("d1:%f"%d1)
    # print("d2:%f"%d2)

    value = math.acos( (v1[0]*v2[0]+v1[1]*v2[1])/(d1*d2) )
    return value

def cal_circle(x, y):
    '''
    Input:
    x : List or array which stores 3 data respectively.
    y : List or array which stores 3 data respectively.
    
    Output:
    xc : X coordinate of the center.
    yc : X coordinate of the center.
    R  : Radius of the center.
    '''

    A = np.array([
        [ 2*x[0], 2*y[0], 1 ],
        [ 2*x[1], 2*y[1], 1 ],
        [ 2*x[2], 2*y[2], 1 ]
    ])
    B = np.array([
        [ x[0]**2 + y[0]**2 ],
        [ x[1]**2 + y[1]**2 ],
        [ x[2]**2 + y[2]**2 ]
    ])

    if abs(np.linalg.det(A)) < 0.0001:
        xc = None
        yc = None
        R = 100000
         
    
    else:
        X = np.linalg.solve(A, B)
        xc = X[0]
        yc = X[1]
        R  = ( X[2] + xc**2 + yc**2 )**(0.5)

    return xc, yc, R

def cal_dist(xi, yi, xf, yf):
    
    dx = xi - xf
    dy = yi - yf
    
    return (dx**2 + dy**2)**(0.5)

def t2v(T):
    '''(Done)
    homogeneous transformation to vector
    '''
    v = np.zeros((3,1))
    v[0:2, 0] = T[0:2, 2]
    v[2, 0] = math.atan2(T[0,1], T[0,0])
    return v

def v2t(vector):
    '''(Done)
    vector to homogeneous transformation
    From local to global
    [              |
            Rotaion  | Translation
        _____________|____________
            0   |   0 |      1
    ]
    '''
    c = math.cos(vector[2])
    s = math.sin(vector[2])
    x = float(vector[0])
    y = float(vector[1])
    T = np.array([
        [c,  -s,  x],
        [s,   c,  y],
        [0,   0,  1]
    ])
    return T




# Main Class
class CAR():
    def __init__(self, topic='/solamr_1/scan_lidar'):
        self.lidar = LiDAR_Association(topic)
        self.odom = ODOM()

        self.updated_node = None
        self.flag_getting_updated = False
        rospy.Subscriber("/solamr_1/optimized_node", Optimized_Node, self._get_updated_node)

    def _get_updated_node(self, node_msg):
        
        self.flag_getting_updated = True
        self.updated_node = node_msg
        return

if __name__ == "__main__":
    rospy.init_node('SLAM_Infomation_Construction', anonymous=True)
    rate = rospy.Rate(0.5)

    try:
        print("sleep for 5 sec.")
        rospy.sleep(1)
        print("Woke UP.")

        # List Set
        '''
        Node Set
        [0]: ID now
        [1]: Node_Pose (global)
        [2]: Landmark
        [3]: Scan
        -------------------------
        Edge Set
        [0]: ID from
        [1]: ID to
        [2]: Edge Pose (relative)
        [3]: Covariance 
        '''
        Node_set = []
        Edge_set = []
        
        node_id = 0
        
        car = CAR('/solamr_1/scan_lidar')
        
        # Declaration of publisher
        node_pub = rospy.Publisher("/solamr_1/collector_node", Node, queue_size=10)
        edge_pub = rospy.Publisher("/solamr_1/collector_edge", Edge, queue_size=10)
        
        current_node = Node()
        current_edge = Edge()

        while not rospy.is_shutdown():
        
            if car.lidar.landmark is not None: 

                # Store Node data
                Node_set.append([
                    node_id,
                    car.odom.x,
                    car.odom.y, 
                    car.odom.yaw,
                    car.lidar.landmark,
                    car.lidar.scan
                ])
                
                current_node.Node_ID = Node_set[-1][0]
                current_node.global_pose.x = Node_set[-1][1]
                current_node.global_pose.y = Node_set[-1][2]
                current_node.global_pose.yaw = Node_set[-1][3]
                # current_node.Landmark = Node_set[-1][4]
                # current_node.Scan = Node_set[-1][5]
                node_pub.publish(current_node)


                # Store Edge data with t = k & t = k - 1
                if len(Node_set) >= 2:
                    A = Node_set[-2]
                    B = Node_set[-1]
                    pose = np.array([
                        [B[1] - A[1]],
                        [B[2] - A[2]],
                        [B[3] - A[3]]
                    ])

                    # Cov = np.array([
                    #     [20,  0,     0],
                    #     [ 0, 20,     0],
                    #     [ 0,  0, 10000]
                    # ])
                    Cov = np.array(
                        [20, 0, 0, 0, 20, 0, 0, 0, 10000]
                    )
                    Edge_set.append([
                        Node_set[-2][0],
                        Node_set[-1][0],
                        pose,
                        Cov
                    ])

                    current_edge.Node_ID_From = Edge_set[-1][0]
                    current_edge.Node_ID_To = Edge_set[-1][1]
                    current_edge.relative_pose.x = Edge_set[-1][2][0]
                    current_edge.relative_pose.y = Edge_set[-1][2][1]
                    current_edge.relative_pose.yaw = Edge_set[-1][2][2]
                    current_edge.covariance = Edge_set[-1][3]
                    current_edge.covariance_shape.row = 3
                    current_edge.covariance_shape.column = 3
                    edge_pub.publish(current_edge)

                if car.flag_getting_updated is True:
                    # update the node info here
                    print("Updated Done")
                    print(car.updated_node)
                    car.flag_getting_updated = False
                    pass

                if node_id > 160:
                    break
                
                node_id += 1
                rate.sleep()
            
        rospy.spin()

    except KeyboardInterrupt:
        pass

    finally:
        pass
        